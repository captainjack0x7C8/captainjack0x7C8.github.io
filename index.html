<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Index</title>
  <meta name="author" content="captainjack0x7c8">
  
  <meta name="description" content="Less is more">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Index">

  
    <meta property="og:image" content>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Index" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Index</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-07-06T16:17:02.000Z"><a href="/2019/07/07/谈谈resole-conf/">2019-07-07</a></time>
      
      
  
    <h1 class="title"><a href="/2019/07/07/谈谈resole-conf/">谈谈resole.conf</a></h1>
  

    </header>
    <div class="entry">
      
        <p>&emsp;<strong>/etc/resolve.conf</strong>文件大家应该很熟悉了，最近被同事问到修改该文件后后总是自动还原的问题，在这里做一个简单的记录。</p>
<h3 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h3><table>
<thead>
<tr>
<th>系统类型</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu Server</td>
<td>18.04</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;nameserver 114.114.114.114&apos; &gt; /etc/resolve.conf</span><br><span class="line">cat /etc/resolve.conf</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure>

<p>一段时间后…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolve.conf</span><br><span class="line"># Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)</span><br><span class="line">#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN</span><br><span class="line"># 127.0.0.53 is the systemd-resolved stub resolver.</span><br><span class="line"># run &quot;systemd-resolve --status&quot; to see details about the actual nameservers.</span><br><span class="line"></span><br><span class="line">nameserver 127.0.0.53</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>通过查看还原后的文件内容，发现两个关键信息</p>
<ul>
<li>systemd-resolve –status</li>
<li>nameserver 127.0.0.53</li>
</ul>
<p>这说明系统将DNS解析服务由systemd的resolve服务托管，resolve.conf文件也由该服务维护。如果想使用自定义DNS服务器，很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop systemd-resolve</span><br><span class="line">systemctl disable systemd-resolve</span><br><span class="line">echo &apos;nameserver 114.114.114.114&apos; &gt; /etc/resolve.conf</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>看文档，看提示信息。一切皆有迹可循。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-07-06T13:51:09.000Z"><a href="/2019/07/06/Spring中被代理对象内部调用/">2019-07-06</a></time>
      
      
  
    <h1 class="title"><a href="/2019/07/06/Spring中被代理对象内部调用/">Spring中被代理对象内部调用</a></h1>
  

    </header>
    <div class="entry">
      
        <p>&emsp;众所周知，Spring AOP是基于动态代理实现的，最近被同事问到在被代理对象中直接进行内部调用，拦截器或切面不生效的问题，在这里做一个简单的记录。<br></p>
<h3 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h3><p>Spring版本：5.1.6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Impl&#123;</span><br><span class="line"></span><br><span class="line">    public void a()&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void b()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;如上所示，在Impl类外部调用a方法时，针对b方法的拦截器或切面并不能生效。原因是这种情形下，this代表被代理对象，调用并没有通过代理对象执行。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>确保使用CGLIB并将代理对象暴露给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取代理对象，强制转型为被代理对象（这里牵扯到CGlLIB的特点，代理对象其实是被代理对象的子类实例）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//继续使用上面的例子</span><br><span class="line">public void a()&#123;</span><br><span class="line">    ((Impl)AopContext.currentProxy()).b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-21T06:38:40.000Z"><a href="/2019/04/21/JVM堆内存详解（转）/">2019-04-21</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/21/JVM堆内存详解（转）/">JVM堆内存详解（转）</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://blog.51cto.com/lizhenliang/2164876?wx=" target="_blank" rel="noopener">From 51CTO</a><br></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>JAVA堆内存管理是影响性能主要因素之一。<br>堆内存溢出是JAVA项目非常常见的故障，在解决该问题之前，必须先了解下JAVA堆内存是怎么工作的，如图：<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/jvm_heap_detail/java_heap_structure.png" alt="image"></p>
<ol>
<li>JVM内存划分为堆内存和非堆内存，堆内存分为年轻代（Young Generation）、老年代（Old Generation），非堆内存就一个永久代（Permanent Generation）。</li>
<li>年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。</li>
<li>堆内存用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收。</li>
<li>非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。</li>
</ol>
<p>在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。<br>元空间有注意有两个参数：</p>
<ul>
<li>MetaspaceSize ：初始化元空间大小，控制发生GC阈值</li>
<li>MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</li>
</ul>
<h3 id="为什么移除永久代？"><a href="#为什么移除永久代？" class="headerlink" title="为什么移除永久代？"></a>为什么移除永久代？</h3><p>移除永久代原因：为融合HotSpot JVM与JRockit VM（新JVM技术）而做出的改变，因为JRockit没有永久代。<br>有了元空间就不再会出现永久代OOM问题了！</p>
<h3 id="分代概念"><a href="#分代概念" class="headerlink" title="分代概念"></a>分代概念</h3><p>新生成的对象首先放到年轻代Eden区，当Eden空间满了，触发Minor GC，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。<br>老年代存储长期存活的对象，占满时会触发Major GC=Full GC，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时。</p>
<ul>
<li>Minor GC ： 清理年轻代 </li>
<li>Major GC ： 清理老年代</li>
<li>Full GC ： 清理整个堆空间，包括年轻代和永久代<br>所有GC都会停止应用所有线程。</li>
</ul>
<h3 id="为什么分代？"><a href="#为什么分代？" class="headerlink" title="为什么分代？"></a>为什么分代？</h3><p>将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及GC频率。针对分类进行不同的垃圾回收算法，对算法扬长避短。</p>
<h3 id="为什么survivor分为两块相等大小的幸存空间？"><a href="#为什么survivor分为两块相等大小的幸存空间？" class="headerlink" title="为什么survivor分为两块相等大小的幸存空间？"></a>为什么survivor分为两块相等大小的幸存空间？</h3><p>主要为了解决碎片化。如果内存碎片化严重，也就是两个对象占用不连续的内存，已有的连续内存不够新对象存放，就会触发GC。</p>
<h3 id="JVM堆内存常用参数"><a href="#JVM堆内存常用参数" class="headerlink" title="JVM堆内存常用参数"></a>JVM堆内存常用参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>堆内存初始大小，单位m、g</td>
</tr>
<tr>
<td>-Xmx（MaxHeapSize）</td>
<td>堆内存最大允许大小，一般不要大于物理内存的80%</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>非堆内存最大允许大小</td>
</tr>
<tr>
<td>-XX:NewSize（-Xns）</td>
<td>年轻代内存初始大小</td>
</tr>
<tr>
<td>-XX:MaxNewSize（-Xmn）</td>
<td>年轻代内存最大允许大小，也可以缩写</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td>
</tr>
<tr>
<td>-Xss</td>
<td>堆栈内存大小</td>
</tr>
</tbody></table>
<h3 id="垃圾回收算法（GC，Garbage-Collection）"><a href="#垃圾回收算法（GC，Garbage-Collection）" class="headerlink" title="垃圾回收算法（GC，Garbage Collection）"></a>垃圾回收算法（GC，Garbage Collection）</h3><p>红色是标记的非活动对象，绿色是活动对象。</p>
<ul>
<li><p>标记-清除（Mark-Sweep）<br>GC分为两个阶段，标记和清除。首先标记所有可回收的对象，在标记完成后统一回收所有被标记的对象。同时会产生不连续的内存碎片。碎片过多会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存，而不得已再次触发GC。<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/jvm_heap_detail/mark-sweep.png" alt="image"></p>
</li>
<li><p>复制（Copy）<br>将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/jvm_heap_detail/copy.png" alt="image"></p>
</li>
<li><p>标记-整理（Mark-Compact）<br>也分为两个阶段，首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。<br>一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/jvm_heap_detail/mark-compact.png" alt="image"></p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></li>
<li><p>串行收集器（Serial）</p>
</li>
</ul>
<p>比较老的收集器，单线程。收集时，必须暂停应用的工作线程，直到收集结束。</p>
<ul>
<li>并行收集器（Parallel）</li>
</ul>
<p>多条垃圾收集线程并行工作，在多核CPU下效率更高，应用线程仍然处于等待状态。</p>
<ul>
<li>CMS收集器（Concurrent Mark Sweep）<br>CMS收集器是缩短暂停应用时间为目标而设计的，是基于标记-清除算法实现，整个过程分为4个步骤，包括：<ul>
<li>初始标记（Initial Mark） </li>
<li>并发标记（Concurrent Mark）</li>
<li>重新标记（Remark）</li>
<li>并发清除（Concurrent Sweep）</li>
</ul>
</li>
</ul>
<p>其中，初始标记、重新标记这两个步骤仍然需要暂停应用线程。初始标记只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段是标记可回收对象，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，这个阶段暂停时间比初始标记阶段稍长一点，但远比并发标记时间段。<br>由于整个过程中消耗最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，CMS收集器内存回收与用户一起并发执行的，大大减少了暂停时间。</p>
<ul>
<li>G1收集器（Garbage First）<br>G1收集器将堆内存划分多个大小相等的独立区域（Region），并且能预测暂停时间，能预测原因它能避免对整个堆进行全区收集。G1跟踪各个Region里的垃圾堆积价值大小（所获得空间大小以及回收所需时间），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，从而保证了再有限时间内获得更高的收集效率。G1收集器工作工程分为4个步骤，包括：<ul>
<li>初始标记（Initial Mark）</li>
<li>并发标记（Concurrent Mark）</li>
<li>最终标记（Final Mark）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
</li>
</ul>
<p>初始标记与CMS一样，标记一下GC Roots能直接关联到的对象。并发标记从GC Root开始标记存活对象，这个阶段耗时比较长，但也可以与应用线程并发执行。而最终标记也是为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录。最后在筛选回收阶段对各个Region回收价值和成本进行排序，根据用户所期望的GC暂停时间来执行回收。</p>
<h3 id="垃圾收集器参数"><a href="#垃圾收集器参数" class="headerlink" title="垃圾收集器参数"></a>垃圾收集器参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseSerialGC</td>
<td>串行收集器</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>并行收集器</td>
</tr>
<tr>
<td>-XX:+UseParallelGCThreads=8</td>
<td>并行收集器线程数，同时有多少个线程进行垃圾回收，一般与CPU数量相等</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>指定老年代为并行收集</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>CMS收集器（并发收集器）</td>
</tr>
<tr>
<td>-XX:+UseCMSCompactAtFullCollection</td>
<td>开启内存空间压缩和整理，防止过多内存碎片</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompaction=0</td>
<td>表示多少次Full GC后开始压缩和整理，0表示每次Full GC后立即执行压缩和整理</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction=80%</td>
<td>表示老年代内存空间使用80%时开始执行CMS收集，防止过多的Full GC</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1收集器</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=0</td>
<td>在年轻代经过几次GC后还存活，就进入老年代，0表示直接进入老年代</td>
</tr>
</tbody></table>
<h3 id="为什么会堆内存溢出？"><a href="#为什么会堆内存溢出？" class="headerlink" title="为什么会堆内存溢出？"></a>为什么会堆内存溢出？</h3><p>在年轻代中经过GC后还存活的对象会被复制到老年代中。当老年代空间不足时，JVM会对老年代进行完全的垃圾回收（Full GC）。如果GC后，还是无法存放从Survivor区复制过来的对象，就会出现OOM（Out of Memory）。</p>
<h5 id="OOM（Out-of-Memory）异常常见有以下几个原因："><a href="#OOM（Out-of-Memory）异常常见有以下几个原因：" class="headerlink" title="OOM（Out of Memory）异常常见有以下几个原因："></a>OOM（Out of Memory）异常常见有以下几个原因：</h5><ol>
<li>老年代内存不足：java.lang.OutOfMemoryError:Javaheapspace</li>
<li>永久代内存不足：java.lang.OutOfMemoryError:PermGenspace</li>
<li>代码bug，占用内存无法及时回收。</li>
</ol>
<p>OOM在这几个内存区都有可能出现，实际遇到OOM时，能根据异常信息定位到哪个区的内存溢出。<br>可以通过添加个参数-XX:+HeapDumpOnOutMemoryError，让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。</p>
<p>熟悉了JAVA内存管理机制及配置参数，下面是对JAVA应用启动选项调优配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot;-server -Xms512m -Xmx2g -XX:+UseG1GC -XX:SurvivorRatio=6 -XX:MaxGCPauseMillis=400 -XX:G1ReservePercent=15 -XX:ParallelGCThreads=4 -XX:</span><br><span class="line">ConcGCThreads=1 -XX:InitiatingHeapOccupancyPercent=40 -XX:+PrintGCDetails  -XX:+PrintGCTimeStamps -Xloggc:/var/log/gc.log&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置堆内存最小和最大值，最大值参考历史利用率设置</li>
<li>设置GC垃圾收集器为G1</li>
<li>启用GC日志，方便后期分析</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>选择高效的GC算法，可有效减少停止应用线程时间。</li>
<li>频繁Full GC会增加暂停时间和CPU使用率，可以加大老年代空间大小降低Full GC，但会增加回收时间，根据业务适当取舍。</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-20T02:02:04.000Z"><a href="/2019/04/20/浅谈ClassLoader双亲委派/">2019-04-20</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/20/浅谈ClassLoader双亲委派/">浅谈ClassLoader双亲委派</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>双亲委派：当类加载器A被请求加载某个类B,则A并不会直接去加载B,而是把这个请求委派给父类加载器C,每一层的类加载器都是如此,因此所有的类加载请求都会委派到顶端的启动类加载器;只有当父类加载器在其搜索范围内不能找到所需的类后,把结果反馈给子类加载器,子类加载器才会尝试去直接加载。</p>
<p>JDK中类加载器分类如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BootStrap ClassLoader</td>
<td>cpp实现，负责加载JAVA_HOME/lib下的类</td>
</tr>
<tr>
<td>Extension ClassLoader</td>
<td>java实现，负责加载JAVA_HOME/lib/ext下的类</td>
</tr>
<tr>
<td>Application ClassLoader</td>
<td>java实现，负责加载程序入口目录下的类</td>
</tr>
<tr>
<td>User ClassLoader</td>
<td>用户自定义</td>
</tr>
</tbody></table>
<p>双亲委派正是基于以上类加载器的设定，明确了类加载的分工和过程，确保类加载器只加载负责范围内的类，从而不会造成混乱。</p>
<blockquote>
<p>对于任意类，都由加载它的类加载器和类本身确定其在JVM中的唯一性。如果同一个类被不同的类加载器加载为不同的实例，则有可能会出现异常（例如行为异常，无法强制转型等）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  The</span><br><span class="line"> * default implementation of this method searches for classes in the</span><br><span class="line"> * following order:</span><br><span class="line"> *</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> *</span><br><span class="line"> *   &lt;li&gt;&lt;p&gt; Invoke &#123;@link #findLoadedClass(String)&#125; to check if the class</span><br><span class="line"> *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method</span><br><span class="line"> *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class</span><br><span class="line"> *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;@link #findClass(String)&#125; method to find the</span><br><span class="line"> *   class.  &lt;/p&gt;&lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If the class was found using the above steps, and the</span><br><span class="line"> * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the &#123;@link</span><br><span class="line"> * #resolveClass(Class)&#125; method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override &#123;@link</span><br><span class="line"> * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span><br><span class="line"> * &#123;@link #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;&#125; method</span><br><span class="line"> * during the entire class loading process.</span><br><span class="line"> *</span><br><span class="line"> * @param  name</span><br><span class="line"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span><br><span class="line"> *</span><br><span class="line"> * @param  resolve</span><br><span class="line"> *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class</span><br><span class="line"> *</span><br><span class="line"> * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span><br><span class="line"> *</span><br><span class="line"> * @throws  ClassNotFoundException</span><br><span class="line"> *          If the class could not be found</span><br><span class="line"> */</span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.</span><br><span class="line"> * This method should be overridden by class loader implementations that</span><br><span class="line"> * follow the delegation model for loading classes, and will be invoked by</span><br><span class="line"> * the &#123;@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method after checking the</span><br><span class="line"> * parent class loader for the requested class.  The default implementation</span><br><span class="line"> * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @param  name</span><br><span class="line"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span><br><span class="line"> *</span><br><span class="line"> * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span><br><span class="line"> *</span><br><span class="line"> * @throws  ClassNotFoundException</span><br><span class="line"> *          If the class could not be found</span><br><span class="line"> *</span><br><span class="line"> * @since  1.2</span><br><span class="line"> */</span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-01T02:15:40.000Z"><a href="/2019/03/01/Feign的继承支持/">2019-03-01</a></time>
      
      
  
    <h1 class="title"><a href="/2019/03/01/Feign的继承支持/">Feign的继承支持</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html#spring-cloud-feign-inheritance" target="_blank" rel="noopener">译自Spring Cloud Document</a></p>
<h2 id="7-7-Feign的继承支持"><a href="#7-7-Feign的继承支持" class="headerlink" title="7.7 Feign的继承支持"></a>7.7 Feign的继承支持</h2><p>Feign通过单继承接口支持模板apis。这样可以把常用操作通过接口进行分组。</p>
<h6 id="UserService-java"><a href="#UserService-java" class="headerlink" title="UserService.java."></a>UserService.java.</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(method = RequestMethod.GET, value =&quot;/users/&#123;id&#125;&quot;)</span><br><span class="line">    User getUser(@PathVariable(&quot;id&quot;) long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="UserResource-java"><a href="#UserResource-java" class="headerlink" title="UserResource.java."></a>UserResource.java.</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserResource implements UserService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="UserClient-java"><a href="#UserClient-java" class="headerlink" title="UserClient.java."></a>UserClient.java.</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package project.user;</span><br><span class="line"></span><br><span class="line">@FeignClient(&quot;users&quot;)</span><br><span class="line">public interface UserClient extends UserService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常不建议在服务器和客户端之间共享接口（Java Interface）。这是一种紧耦合，而且这样也无法使用Spring MVC（方法中的参数映射不会被继承）。</p>
</blockquote>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-02-07T07:57:00.000Z"><a href="/2019/02/07/快速排序/">2019-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2019/02/07/快速排序/">快速排序</a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>快速排序使用分治理念，将目标数组每次划分为左右两个区间分而治之。因而他也是一种不稳定排序算法，最坏情况下，每次选择的基准都是分区内最小或最大数，造成左/右分区为空，这种情况下，时间复杂度与冒泡排序相同，等于O(n^2)</p>
<h6 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code."></a>Talk is cheap, show me the code.</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * a[]   目标数组</span><br><span class="line">     * low   低位</span><br><span class="line">     * hight 高位</span><br><span class="line">     **/ </span><br><span class="line">    public static void sort(int a[], int low, int hight) &#123;</span><br><span class="line">        int i, j, index;</span><br><span class="line">        if (low &gt; hight) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //左分区起始位</span><br><span class="line">        i = low;</span><br><span class="line">        //右分区结束位</span><br><span class="line">        j = hight;</span><br><span class="line">        // 用子表的第一个记录做基准</span><br><span class="line">        index = a[i];</span><br><span class="line">        // 从表的两端交替向中间扫描</span><br><span class="line">        while (i &lt; j) &#123; </span><br><span class="line">            //先从高位向低位扫描</span><br><span class="line">            while (i &lt; j &amp;&amp; a[j] &gt;= index)</span><br><span class="line">                j--;</span><br><span class="line">            if (i &lt; j)</span><br><span class="line">                //用比基准小的记录替换低位记录</span><br><span class="line">                a[i++] = a[j];</span><br><span class="line">            //再从低位向高位扫描</span><br><span class="line">            while (i &lt; j &amp;&amp; a[i] &lt; index)</span><br><span class="line">                i++;</span><br><span class="line">            if (i &lt; j)</span><br><span class="line">                // 用比基准大的记录替换高位记录</span><br><span class="line">                a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        // 将基准数值替换回 a[i]</span><br><span class="line">        a[i] = index;</span><br><span class="line">        //继续分区</span><br><span class="line">        sort(a, low, i - 1); // 对低子表进行递归排序</span><br><span class="line">        sort(a, i + 1, hight); // 对高子表进行递归排序</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void quickSort(int a[]) &#123;</span><br><span class="line">        sort(a, 0, a.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        int a[] = &#123; 48, 38, 69, 97, 76, 13, 37, 48 &#125;;</span><br><span class="line">        quickSort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:captainjack0x7c8.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/AOP/">AOP</a><small>1</small></li>
  
    <li><a href="/tags/Feign/">Feign</a><small>1</small></li>
  
    <li><a href="/tags/JDK/">JDK</a><small>1</small></li>
  
    <li><a href="/tags/JVM/">JVM</a><small>1</small></li>
  
    <li><a href="/tags/Spring-Cloud/">Spring Cloud</a><small>1</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>1</small></li>
  
    <li><a href="/tags/算法/">算法</a><small>1</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 captainjack0x7c8
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
