<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Index</title>
  <meta name="author" content="captainjack0x7c8">
  
  <meta name="description" content="Less is more">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Index">

  
    <meta property="og:image" content>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Index" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Index</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-08-17T16:04:55.000Z"><a href="/2019/08/18/JVM如何使用Native内存/">2019-08-18</a></time>
      
      
  
    <h1 class="title"><a href="/2019/08/18/JVM如何使用Native内存/">JVM如何使用Native内存</a></h1>
  

    </header>
    <div class="entry">
      
        <h5 id="译自IBM-Developerworks"><a href="#译自IBM-Developerworks" class="headerlink" title="译自IBM Developerworks"></a>译自IBM Developerworks</h5><h5 id="Thanks-for-the-memory-Linux"><a href="#Thanks-for-the-memory-Linux" class="headerlink" title="Thanks for the memory, Linux"></a>Thanks for the memory, Linux</h5><h5 id="Understanding-how-the-JVM-uses-native-memory-on-Windows-and-Linux"><a href="#Understanding-how-the-JVM-uses-native-memory-on-Windows-and-Linux" class="headerlink" title="Understanding how the JVM uses native memory on Windows and Linux"></a>Understanding how the JVM uses native memory on Windows and Linux</h5><p><a href="https://www.ibm.com/developerworks/library/j-nativememory-linux/" target="_blank" rel="noopener">原文链接</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java堆是我们在写程序时最常用的内存区域，它是存放所有Java对象的位置（译者注：现在未逃逸对象已经使用了栈上分配）。JVM旨在使我们不受主机特性的影响，所以在探讨内存的时候，很自然的就会想起堆内存。毫无疑问，你肯定遇到过由于对象泄漏或者堆内存过小导致的堆内存溢出，并且可能已经掌握了一些调试相关问题的手段。但是，当使用使用Java处理更多数据和更多并发时，你可能会遇到无法使用常规手段修复的内存溢出错误，即使堆内存未满，也会抛出错误(OutOfMemoryError)的情况。发生这种情况时，你需要了解Java运行时环境（JRE）内部的情况。<br></p>
<p>Java应用在Java运行时的虚拟化环境中运行，但运行时本身也是用编程语言（例如C）开发的、使用native资源（包括内存）的程序。与Java应用使用的Java堆内存不同，native内存是系统运行时进程可用的内存。所有虚拟资源（包括Java堆和Java线程）都必须与虚拟机运行时使用的数据一起存储在native内存中。这意味着宿主机硬件和操作系统对native内存的限制会影响使用者对Java应用的操作。<br></p>
<p>本文是在不同平台上涵盖相同主题的两篇文章之一。这两者中，你将了解native内存是啥，Java运行时如何使用它，它看起来是啥，以及如何调试native内存溢出错误。本文主要介绍在Windows和Linux平台，并不关注任何特定的运行时（JVM）实现。<a href="https://www.ibm.com/developerworks/java/library/j-nativememory-aix/" target="_blank" rel="noopener">配套文章</a>介绍了AIX，重点介绍了IBM®DeveloperKit for Java。 （该文章中关于IBM实现的信息对于AIX以外的平台也是如此，因此如果你在Linux上使用IBM Developer Kit for Java或者在IBM 32位Runtime Environment for Windows上，可能会发现该文章也很有用。)</p>
<h3 id="回顾native内存"><a href="#回顾native内存" class="headerlink" title="回顾native内存"></a>回顾native内存</h3><p>首先，我将解释操作系统和底层硬件对native内存的限制。如果你比较熟悉编程语言管理动态内存（例如C语言），可以直接跳到下一部分。<br></p>
<h4 id="硬件限制"><a href="#硬件限制" class="headerlink" title="硬件限制"></a>硬件限制</h4><p>Native进程的许多限制是由硬件而不是操作系统引起的。每台计算机都有一个处理器和一些内存（RAM）。处理器拥有有一个或多个处理单元，将数据流解释为要执行的指令，执行整数、浮点运算以及其他高级计算。处理器有许多寄存器，用作执行计算的工作存储器;寄存器大小决定了单个计算可以使用的最大容量。<br></p>
<p>处理器通过存储器总线连接到物理存储器。物理地址长度（处理器用于索引物理RAM的地址）限制了可以寻址的内存数量。例如，16位物理地址可以从0x0000到0xFFFF寻址，包括2 ^ 16 = 65536个唯一的存储单元。如果每个地址引用一个存储字节，则16位物理地址将允许处理器寻址64KB的存储器。<br></p>
<p>可以使用一定数量的位来描述处理器。这取决于寄存器的大小，但有例外（比如390 31位）其中它指的是物理地址长度。对于桌面和服务器平台，一般是31、32或64位;对于嵌入式设备和微处理器，可以低至4位。物理地址大小可以与寄存器位宽相等，也可以更大或更小。对于兼容的操作系统来说，大多数64位处理器可以运行32位程序。<br></p>
<p>表1列出了一些流行的Linux版本和Windows架构及其寄存器位宽和物理地址长度：</p>
<table>
<thead>
<tr>
<th>架构</th>
<th>寄存器位宽（bits）</th>
<th>物理地址长度(bits)</th>
</tr>
</thead>
<tbody><tr>
<td>(现代)英特尔X86</td>
<td>32</td>
<td>32<br>36使用物理地址扩展（奔腾Pro及更高版本）</td>
</tr>
<tr>
<td>x86 64</td>
<td>64</td>
<td>目前48位（范围后期会增加）</td>
</tr>
<tr>
<td>PPC64</td>
<td>64</td>
<td>在POWER 5上为50位</td>
</tr>
<tr>
<td>390 31-bit</td>
<td>32</td>
<td>31</td>
</tr>
<tr>
<td>390 64-bit</td>
<td>64</td>
<td>64</td>
</tr>
</tbody></table>
<blockquote>
<p>表1.一些常用处理器架构的寄存器位宽和物理地址长度</p>
</blockquote>
<h4 id="操作系统与虚拟内存"><a href="#操作系统与虚拟内存" class="headerlink" title="操作系统与虚拟内存"></a>操作系统与虚拟内存</h4><p>对于不使用操作系统的程序来说，可以使用处理器寻址范围内的所有内存。但是为了享受多任务和硬件抽象等功能，大部分开发者还是会使用操作系统。<br></p>
<p>在Windows和Linux等多任务操作系统中，许多程序共用包括内存在内的系统资源。每个程序都需要分配物理内存才能工作。理想情况下，可以设计这样一个操作系统，使每个程序可以直接使用物理内存，并且保证只使用由系统分配的内存。一些嵌入式操作系统的工作方式就类似这样，但在由多个未经过集成测试的程序组成的环境中并不实用，因为任何程序都可能破坏其他程序或操作系统本身的内存。<br></p>
<p>虚拟内存允许多个进程共享物理内存，而且不会破坏彼此的数据。在使用虚拟内存的操作系统（例如Windows，Linux等其他操作系统）中，每个程序都有自己的虚拟地址空间：物理地址的逻辑区域，其大小由该系统的地址长度决定（31,32或桌面和服务器平台的64位）。进程中的虚拟地址空间可以映射到物理内存、文件或任何其他可寻址存储设备。操作系统可以将物理内存中数据移入和移出交换区域（Windows上的页面文件或Linux上的交换分区），以便充分利用物理内存。当程序试图使用虚拟地址访问存储器时，OS与片上硬件结合将该虚拟地址映射到物理位置。该位置可以是物理RAM，文件或页面文件/交换分区。如果已将某片内存区域移动到交换空间，则在使用之前将会把它重新加载到物理内存中。图1展示了虚拟内存通过进程地址空间映射以实现共享资源的工作原理：<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/virtual_memory.gif" alt="图1.虚拟内存将进程地址空间映射到物理资源"><br></p>
<p>每个程序实例都会作为一个进程运行。Linux和Windows上的进程是有关操作系统控制的资源（例如文件和套接字）信息的集合，通常对应一个虚拟地址空间（在某些架构中大于一个），和至少一个执行线程。<br></p>
<p>虚拟地址长度可以小于处理器的物理地址长度。英特尔x86 32位最初有32位物理地址，允许处理器处理4GB存储空间。后来增加加了物理地址扩展（PAE）功能，把物理地址长度扩展到36位，支持安装和寻址最多64GB的RAM。PAE支持操作系统将32位4GB虚拟地址空间映射到更大的物理地址空间，但它并不支持每个进程具有64GB虚拟地址空间。即，如果在32位的英特尔服务器上使用超过4GB的内存，则无法把全部内存直接映射到单个进程中。<br></p>
<p>Address Windowing Extensions功能允许Windows进程将其32位地址空间的一部分作为滑动窗口映射到更大的内存区域。 Linux使用基于将区域映射到虚拟地址空间的类似技术。这意味着虽然用户无法直接引用超过4GB的内存，但可以使用更大的内存区域。</p>
<h4 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h4><p>虽然每个进程都有自己的地址空间，但用户程序并不能全部使用。地址空间分为用户态和内核态。内核位于操作系统中，包含了计算机硬件接口、调度程序以及提供网络和虚拟内存等服务等功能。<br></p>
<p>作为计算机引导序列的一部分，操作系统内核运行并初始化硬件。一旦内核配置了硬件及其自身的内部状态，就会启动第一个用户态进程。如果用户程序需要使用操作系统提供的服务，它可以执行系统调用从而跳转到内核程序，然后内核程序执行请求。对于诸如读取和写入文件，联网以及启动新进程等操作，通常需要系统调用。</p>
<p>内核在执行系统调用时需要访问自己的内存和调用进程的内存。因为正在执行当前线程的处理器被配置为使用当前进程的地址空间映射来映射虚拟地址，所以大多数操作系统将每个进程地址空间的一部分映射到公共内核存储器区域。映射供内核使用的地址空间部分称为内核态空间;可以由用户应用程序使用的其余部分称为用户态空间。<br></p>
<p>内核态和用户态空间的平衡因操作系统而异，甚至在不同硬件架构上运行的相同操作系统的实例之间也存在差异。这种平衡一般是可配置的，可为用户态程序或内核态程序提供更多空间。压缩内核态区域可能会导致诸如限制可以同时登录的用户数量或可以运行的进程数量等问题;较小的用户态空间则意味着供开发者使用的空间较小。<br></p>
<p>默认情况下，在32位Windows具有2GB的用户态空间和2GB的内核态空间。某些Windows版本上，通过将<br><em>/3GB</em><br>配置项开关添加到引导配置并使用<br><em>/LARGEADDRESSAWARE</em><br>配置项开关重新链接应用程序，可以将用户态空间配置为3GB，内核空间为1GB。在32位Linux上，默认用户态空间为3GB和内核态空间为1GB。有些Linux发行版提供了一种名为hugemem，支持4GB用户态空间的内核。为实现此目的，内核拥有自己的地址空间，用于进行系统调用。在这种情况下，虽然用户态空间变大了，但系统调用变的更慢，因为操作系统必须在用户态和内核态的地址空间之间复制数据，并在每次进行系统调用时重置进程地址空间映射。图2展示了32位Windows的地址空间布局：</p>
<p><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/windows_address_space.gif" alt="图2. 32位Windows的地址空间布局"></p>
<p>图3显示了32位Linux的地址空间布局：<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/linux_address_space.gif" alt=" 图3. 32位Linux的地址空间布局"></p>
<p>对于Linux 390 31位架构，使用单独的内核地址空间使得对于小于2GB的地址空间并不适合划分独立地址空间;但是390架构可以在工作同时使用多个地址空间而不会影响性能。<br></p>
<p>进程地址空间必须包含程序所需的所有内容：包括程序本身和它使用的共享库（Windows上的DLL，Linux上的.so文件）。共享库不仅可以占用程序不能存储数据的空间，还能分割地址空间并减少可以作为连续块分配的内存。这在使用3GB用户态空间的Windows x86上运行的程序中很明显。 DLL是由首选的加载地址构建的：当加载DLL时，它被映射到特定位置的地址空间，除非该位置已被占用，此时，它会被重新定位并加载到其他位置。最初设计Windows NT时，用户态空间为2GB，系统库被加载至2GB的边界附近，从而使大部分用户态空间可供用户程序使用。当用户态空间扩展到3GB时，系统共享库仍然加载到2GB附近：位于用户空间的中间。虽然总用户态空间为3GB，但无法分配3GB的内存块，因为中间还隔着共享库。<br></p>
<p>在Windows上使用<br><em>/3GB</em><br>开关可将内核空间减少到原先设计的一半(1GB)。在某些情况下，可能在耗尽1GB内核态空间时遇到慢I/O或创建新用户会话的问题。虽然<em>/3GB</em>开关对某些应用程序非常有价值，但使用它的任何环境都应在部署之前进行全面的压力测试。<br></p>
<p>Native内存泄漏或使用太多的native内存使用会导致不同的问题，具体取决于是否耗尽地址空间或物理内存。耗尽地址空间通常只发生在32位的进程中：因为最大4GB很容易分配。64位进程有成百上千GB的用户态空间，所以很难耗尽。如果你耗尽了Java进程的地址空间，Java运行时就会出现我将在本文后面描述的奇怪症状。在进程地址空间比物理内存更大的系统上运行时，内存泄漏或过度使用native内存会强制操作系统将某些native进程的虚拟地址空间交换至外存。访问已被交换的内存地址比读取驻留（物理内存）地址要慢得多，因为操作系统必须从硬盘驱动器读取数据。为了可以分配足够的内存，可能耗尽所有物理内存和交换分区（页面文件）;在Linux上，这会触发内核内存不足（OOM）杀手，它会强行杀死占用大量内存的进程。在Windows上，分配开始失败的方式与地址空间已满时的方式相同。<br></p>
<p>如果你使用的虚拟内存比物理内存更大，很明显，<del>在进程因为内存耗尽而被杀死之前很久就会出现问题</del>。系统会停止响应：大部分时间都用于在交换空间和物理内存之间来回复制。发生这种情况时，计算机和各个应用程序的性能将变得非常差。当JVM的Java堆被交换出时，GC的性能变得极差，以至于程序好像挂起了。如果在同一台计算机上运行多个Java程序实例时，物理内存必须足以容纳所有Java堆。</p>
<h3 id="Java运行时如何使用native内存"><a href="#Java运行时如何使用native内存" class="headerlink" title="Java运行时如何使用native内存"></a>Java运行时如何使用native内存</h3><p>Java运行时是操作系统中的进程，它受到作者在前一节中概述的硬件和操作系统限制的约束。运行时环境提供了由未知代码驱动的功能，所以无法预测运行时环境在每种情况下都需要哪些资源。 在Java环境中，Java应用程序执行的每个操作都可能会影响提供该环境的运行时资源需求。本节介绍Java应用程序使用native内存的方式和以及为啥要这样用。<br></p>
<h4 id="堆与GC"><a href="#堆与GC" class="headerlink" title="堆与GC"></a>堆与GC</h4><p>Java堆是分配对象的内存区域。大多数Java SE实现都有一个逻辑堆，尽管一些专业Java运行时（例如Java实时规范（RTSJ））有多个堆。根据用于管理堆内存的垃圾收集（GC）算法，可以将单个物理堆拆分为逻辑部分。这些部分通常由被Java内存管理器（包括垃圾收集器）管理，native内存的连续区域实现。<br><br>在Java命令行中，-Xmx和-Xms选项可以控制堆大小（mx是堆的最大大小，ms是初始大小）。虽然逻辑堆大小可以根据堆上对象数量和GC消耗的时间来控制，但使用的native内存数量是不变的。由于大部分GC算法依赖于连续的内存块，因此堆需要扩展时，无法分配更多native内存，All heap memory must be reserved up front。<br></p>
<p>Reserving native memory is not the same as allocating it. When native memory is reserved, it is not backed with physical memory or other storage. Although reserving chunks of the address space will not exhaust physical resources, it does prevent that memory from being used for other purposes. A leak caused by reserving memory that is never used is just as serious as leaking allocated memory.<br></p>
<p>Some garbage collectors minimise the use of physical memory by decommitting (releasing the backing storage for) parts of the heap as the used area of heap shrinks.<br></p>
<p>More native memory is required to maintain the state of the memory-management system maintaining the Java heap. Data structures must be allocated to track free storage and record progress when collecting garbage. The exact size and nature of these data structures varies with implementation, but many are proportional to the size of the heap.</p>
<h4 id="即时编译-JIT"><a href="#即时编译-JIT" class="headerlink" title="即时编译(JIT)"></a>即时编译(JIT)</h4><p>JIT编译器在运行时将Java字节码编译为优化的native可执行代码。这极大地提高了Java运行时的运行时速度，并允许Java应用程序以与native代码一样的速度运行。<br></p>
<p>字节码编译使用native内存（与gcc等静态编译器需要运行内存的方式相同），但JIT的输入（字节码）和输出（可执行代码）也必须存储在native内存中。包含许多JIT编译方法的Java应用程序比较小的应用程序使用更多的native内存。</p>
<h4 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h4><p>Java应用程序由定义对象结构和方法逻辑的类组成。它们还使用Java运行时类库（例如java.lang.String）中的类，并且可以使用第三方库。只要它们被使用，这些类就需要存储在内存中。<br></p>
<p>如何存储类因实现而异。Sun JDK使用堆中的永久代（PermGen）。Java 5以后的IBM实现为每个类加载器分配native内存块，并将类数据存储在里面。现代Java运行时具有诸如类共享之类的技术，这些技术可能需要将共享内存映射到地址空间。要了解这些分配机制如何影响Java运行时的本机占用空间，可以阅读该实现的官方文档。但这些实现仍然存在共同点。<br></p>
<p>在最基本的层面上，使用更多类会占用更多内存。这可能意味着您的native内存使用量增加，或者您必须显式调整某个区域的大小：比如永久代或共享类缓存，以便足够存放所有类。请记住，不仅是程序需要足够的内存;框架、应用程序服务器、第三方库和Java运行时都包含有按需加载而且占用内存的类。<br></p>
<p>Java运行时可以卸载类来回收空间，但只能在严格的条件下进行。不可能卸载单个类。卸载类加载器，取出它们加载的所有类。只有在以下情况下才能卸载类加载器：</p>
<ul>
<li>Java堆没有该类加载器（java.lang.ClassLoader）的实例。</li>
<li>Java堆没有由该类加载器加载的java.lang.Class的实例。</li>
<li>该类加载器加载的任何类的对象都不在Java堆上存活（引用）。</li>
</ul>
<p>注意，Java运行时为所有Java应用程序设置的三个默认类加载器： bootstrap、extension和application均不满足这些标准;因此，任何系统类（如java.lang.String）或者通过application类加载器加载的任何应用程序类都无法在运行时释放。<br></p>
<p><del>即使类加载器符合垃圾回收条件，运行时也只会将类加载器作为GC循环的一部分进行收集。某些实现仅在某些GC周期中卸载类加载器</del>。<br></p>
<p>在没有意识到的情况下，也可以在运行时生成类。许多J2EE应用程序使用JavaServer Pages（JSP）技术来生成Web页面。使用JSP为每个执行的.jsp页面生成一个类，因此，会延长加载这些类的类加载器的生命周期：通常是Web应用程序的生命周期。<br></p>
<p>生成类的另一种常用方法是使用Java反射。反射的工作方式因Java实现而异，但Sun和IBM实现都使用下面的方法。<br></p>
<p>使用java.lang.reflect API时，Java运行时必须将反射对象（如java.lang.reflect.Field）的方法连接到反射的对象或类。这可以通过使用Java native接口（JNI）访问器来完成，该访问器使用方便但速度很慢，或者在运行时为要反射的对象动态生成所需类。第二种方法使用麻烦但执行速度快，因此非常适合经常使用反射技术的应用程序。<br></p>
<p>Java运行时在反射类的前几次使用JNI方法，但在多次使用之后，访问器被扩展为字节码访问器，这样需要构建相关类并用新的类加载器加载。大量反射可能会导致创建许多访问器类和类加载器。保持对反射对象的引用会使这些类保持活跃并继续占用空间。因为创建字节码访问器非常慢，所以Java运行时可以缓存这些访问器供以后使用。某些应用程序和框架还会缓存反射对象，因此也会占用native内存。</p>
<h4 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h4><p>JNI允许native代码（使用native编译语言，如C和C++编写的应用程序）调用Java方法，反之亦然。Java运行时本身在很大程度上依赖于JNI代码来实现类库函数，例如文件和网络I/O. JNI应用程序可以通过三种方式增加Java运行时占用的native内存：</p>
<ul>
<li>JNI应用程序的本机代码被编译为加载到进程地址空间的共享库或可执行文件。大型native应用程序只需加载就可占据很大一部分进程地址空间。</li>
<li>Native代码必须与Java运行时共享地址空间。</li>
<li>某些JNI函数可以使用native内存作为其正常操作的一部分。GetTypeArrayElements和GetTypeArrayRegion函数可以将Java堆数据复制到native内存缓冲区，以便使用native代码。是否复制取决于运行时实现。（IBM Developer Kit for Java 5.0及更高版本生成native副本。）以这种方式访问Java堆中的大量数据可能会使用相应数量的native堆。</li>
</ul>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>Java 1.4中添加的新I/O（NIO）相关类引入了基于通道和缓冲区的新I/O方法。除了基于Java堆内存实现的I/O缓冲区之外，NIO还添加了对native内存实现的的DirectByteBuffers（使用java.nio.ByteBuffer.allocateDirect（）方法分配）的支持。DirectByteBuffers可以直接传递给操作系统库函数来执行I/O：某些情况下这样做明显速度更快，因为可以避免在Java堆和native堆之间复制数据（即零拷贝，译者注）。</p>
<p>那么，DirectByteBuffer数据究竟在哪里存储？应用程序仍然使用Java堆上的对象来编排I/O操作，但带有数据的缓冲区在native内存中：Java堆对象仅包含对native堆缓冲区的引用。非直接的ByteBuffer将其数据保存在Java堆上的byte数组中。图4显示了直接和非直接ByteBuffer对象之间的区别：<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/bytebuffers.gif" alt=" 图4.直接和非直接java.nio.ByteBuffers的内存拓扑"><br><br><br>DirectByteBuffer对象自动清理其对应的native缓冲区，但只能作为Java堆GC的一部分执行：因此它们不会自动响应native堆上的压力。GC仅在Java堆变满时才会发生：无法继续分配内存时，或者Java应用程序显式调用，并不推荐显示调用，因为会导致性能问题（译者注，Full GC会导致STW）。<br></p>
<p>极端情况下，native堆已满并且一个或多个DirectByteBuffers符合GC条件（可以在native堆中释放空间），但由于Java堆还没有满，所以不会GC。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>程序中的每个线程都需要内存来存储其堆栈（用于保存局部变量的内存区域以及调用函数时的状态）。每个Java线程都需要运行堆栈空间。根据实现，Java线程可以具有单独的native和Java堆栈。除了堆栈空间之外，每个线程还需要一些native内存用于thread-local存储和内部数据结构。<br><br>栈大小因Java实现和架构而异。某些实现可以指定Java线程的栈大小。通常在256KB和756KB之间。<br><br>尽管每个线程使用的内存量非常小，但对于具有数百个线程的程序，线程栈的总内存使用量可能很大。当程序中的线程数量比可用处理器数量多很多时，会导致效率降低和内存使用量增加。</p>
<h3 id="如何判断我的native内存是否耗尽？"><a href="#如何判断我的native内存是否耗尽？" class="headerlink" title="如何判断我的native内存是否耗尽？"></a>如何判断我的native内存是否耗尽？</h3><p>Java运行时处理Java堆内存耗尽和native堆内存耗尽的方式完全不同，尽管这两种情况都可能出现类似的症状。Java程序在Java堆耗尽时很难运行：因为Java应用程序很难在不分配对象的情况下执行任何操作。一旦Java堆填满，GC性能就会变得很糟并产生OutOfMemoryErrors。<br></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-08-12T13:28:53.000Z"><a href="/2019/08/12/AQS漫谈/">2019-08-12</a></time>
      
      
  
    <h1 class="title"><a href="/2019/08/12/AQS漫谈/">AQS漫谈</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><p>AQS是JDK提供的同步器抽象类，主要用于实现各种用途的锁（信号量，闭锁，可重入读写锁），本文主要记录AQS组成结构和核心能力分析。</p>
<h4 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li>head：Node //同步队列头节点</li>
<li>tail：Node //同步队列尾节点</li>
<li>state：int //当前同步状态</li>
<li>unsafe：Unsafe.getUnsafe()</li>
<li>stateOffset：long</li>
<li>headOffset：long</li>
<li>tailOffset：long</li>
<li>waitStatusOffset：long</li>
<li>nextOffset：long</li>
</ul>
<h5 id="方法（Protected）"><a href="#方法（Protected）" class="headerlink" title="方法（Protected）"></a>方法（Protected）</h5><ul>
<li>getState()：int //获取同步状态</li>
<li>setState()：int //设置同步状态</li>
<li>compareAndSetState(int, int)：int //使用CAS设置同步状态</li>
<li>tryAcquire(int)：boolean //尝试获取独占锁，实现时应先查看当前对象是否支持独占锁。</li>
<li>tryRelease(int)：boolean //尝试释放独占锁</li>
<li>tryAcquireShared(int)：boolean //尝试获取共享锁</li>
<li>tryReleaseShared(int)：boolean //尝试释放共享锁</li>
<li>isHeldExclusively()：boolean //当前线程是否获得了独占锁</li>
</ul>
<h5 id="方法（Public）"><a href="#方法（Public）" class="headerlink" title="方法（Public）"></a>方法（Public）</h5><ul>
<li>acquire(int)：void //获取独占锁（不响应中断）</li>
<li>acquireInterruptibly(int)：void //获取独占锁（响应中断）</li>
<li>tryAcquireNanos(int, long)：boolean //获取独占锁（不响应中断），若等待超时则失败</li>
<li>release(int)：boolean //释放独占锁，可以用来实现Lock.unlock()</li>
<li>acquireShared(int)：void //获取独占锁（不响应中断）</li>
<li>acquireSharedInterruptibly(int)：void //获取独占锁（响应中断）</li>
<li>tryAcquireSharedNanos(int, long)：boolean  //获取共享锁（不响应中断），若等待超时则失败</li>
<li>releaseShared(int)：boolean //释放共享锁</li>
<li>hasQueuedThreads(int)：boolean //同步队列中是否有线程在等待</li>
<li>hasContended()：boolean //查询是否其他线程也曾竞争该同步器；即是否有线程已经阻塞。</li>
<li>getFirstQueuedThread()：Thread //获取第一个进入同步队列的线程（等待时间最长的）。</li>
<li>isQueued(Thread)：boolean //线程是否在同步队列中</li>
<li>hasQueuedPredecessors()：boolean //判断当前线程是否有前导节点，即判断当前线程是否在同步队列的队首，来返回同步队列是否有比当前线程等待更久的线程。</li>
<li>getQueueLength()：int //返回同步队列的预估长度</li>
<li>getQueuedThreads()：Collection<thread> //获取同步队列中的线程集合</thread></li>
<li>getExclusiveQueuedThreads()：Collection<thread> //获取同步队列中，等待获取独占锁的线程集合</thread></li>
<li>getSharedQueuedThreads()：Collection<thread> //获取同步队列中，等待获取共享锁的线程集合</thread></li>
<li>owns(ConditionObject)：boolean //判断当前同步器是否使用了给定condition</li>
<li>hasWaiters(ConditionObject)：boolean //判断是否有线程在给定condition等待</li>
<li>getWaitQueueLength(ConditionObject)：int //返回在给定condition上等待的线程估计数量</li>
<li>getWaitingThreads(ConditionObject)：Collection<thread> //返回在给定condition上等待的线程集合。</thread></li>
<li>toString()：String</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-08-11T03:33:14.000Z"><a href="/2019/08/11/synchronized实现中的锁膨胀/">2019-08-11</a></time>
      
      
  
    <h1 class="title"><a href="/2019/08/11/synchronized实现中的锁膨胀/">synchronized实现中的锁膨胀</a></h1>
  

    </header>
    <div class="entry">
      
        <p>JVM在不同的竞争情况下，对synchronized提供了不同的优化方式</p>
<ul>
<li>锁消除</li>
<li>自旋</li>
<li>自适应自旋</li>
</ul>
<p>在优化过程中锁主要存在4种状态：</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<p>这四种状态会根据资源竞争情况进行膨胀（升级）。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的目的是为了消除无竞争情况下的同步原语，从而进一步提升性能。‘偏’指的是该锁会偏向于首先获得他的线程，如果在执行过程中，该锁未被其他的线程获取，则持有偏向锁的线程就一直不需要同步。</p>
<h5 id="获取偏向锁的过程"><a href="#获取偏向锁的过程" class="headerlink" title="获取偏向锁的过程"></a>获取偏向锁的过程</h5><ol>
<li>检查Mark World偏向锁是否打开。若为1，则执行步骤2，否则代表不支持偏向锁。</li>
<li>检查Mark World储存的线程ID是否为当前线程ID，如果是则执行同步块，否则执行步骤3.</li>
<li>使用CAS操作将Mark World中线程ID改为当前线程ID，若成功则执行同步代码块，否则执行步骤4。</li>
<li>当拥有该锁的线程到达安全点后，挂起该线程，升级为轻量级锁。</li>
</ol>
<h5 id="释放偏向锁的过程"><a href="#释放偏向锁的过程" class="headerlink" title="释放偏向锁的过程"></a>释放偏向锁的过程</h5><ol>
<li>偏向锁采取了竞争才会释放锁的方案，线程并不会主动放弃偏向锁，需要等待其他线程竞争。</li>
<li>等待全局安全点。</li>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果处于非活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于无锁状态，则恢复到无锁状态（01），以允许其他线程竞争，如果锁对象处于锁定状态，则挂起持有偏向锁的线程，并将对象头Mark World的锁记录指针改为当前线程的锁记录，锁升级为轻量锁。</li>
</ol>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁区别于使用mutex方式实现的重量级锁，他使用对象头中的Mark World进行同步。</p>
<h5 id="获取轻量锁的过程"><a href="#获取轻量锁的过程" class="headerlink" title="获取轻量锁的过程"></a>获取轻量锁的过程</h5><ol>
<li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</li>
<li>拷贝对象头中的Mark Word复制到锁记录中。</li>
<li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</li>
<li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li>
<li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li>
</ol>
<h5 id="释放轻量锁的过程"><a href="#释放轻量锁的过程" class="headerlink" title="释放轻量锁的过程"></a>释放轻量锁的过程</h5><ol>
<li>使用CAS操作将对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来(依据Mark Word中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤2，否则执行步骤3。</li>
<li>如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。</li>
<li>如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。</li>
</ol>
<h4 id="该过程的完整流程图"><a href="#该过程的完整流程图" class="headerlink" title="该过程的完整流程图"></a>该过程的完整流程图</h4><p><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/lock_expand.png" alt="image"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-08-05T07:31:56.000Z"><a href="/2019/08/05/MySQL单表访问方式/">2019-08-05</a></time>
      
      
  
    <h1 class="title"><a href="/2019/08/05/MySQL单表访问方式/">MySQL单表访问方式</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Access-method"><a href="#Access-method" class="headerlink" title="Access method"></a>Access method</h2><p>版本5.7</p>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<strong>system</strong>。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>当根据主键或唯一二级索引列与常数进行等值匹配时，对单表的访问方法就<strong>const</strong>。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<strong>ref</strong>。</p>
<h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是<strong>ref_or_null</strong>。</p>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>如果使用索引获取某些范围区间的记录，那么就可能使用到<strong>range</strong>访问方法。</p>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<strong>index</strong>。</p>
<h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<strong>eq_ref</strong>。</p>
<h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h3><p>在一般情况下执行一个查询时最多只会用到单个二级索引，特殊情况下也可能在一个查询中使用到多个二级索引，这种使用到多个索引来完成一次查询的执行方法称之为<strong>index_merge</strong>，具体的合并方式分为以下三种</p>
<ul>
<li>Intersection：交集，某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集。<ul>
<li>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</li>
<li>主键列可以是范围匹配。</li>
</ul>
</li>
<li>Union：并集，适用于使用不同索引的搜索条件之间使用OR连接起来的情况。<ul>
<li>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。</li>
<li>主键列可以是范围匹配。</li>
<li>使用<strong>Intersection</strong>索引合并的搜索条件。</li>
</ul>
</li>
<li>Sort-Union：先按照二级索引记录的主键值进行排序，之后按照<strong>Union</strong>索引合并方式执行的方式称之为<strong>Sort-Union</strong>索引合并，显然<strong>Sort-Union</strong>索引合并比单纯的<strong>Union</strong>索引合并多了一步对二级索引记录的主键值排序的过程。</li>
</ul>
<h3 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h3><p>类似于两表连接中被驱动表的<strong>eq_ref</strong>访问方法，<strong>unique_subquery</strong>是针对在一些包含IN子查询的查询语句中，如果查询优化器决定将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的type列的值就是<strong>unique_subquery</strong>。</p>
<h3 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h3><p>与<strong>unique_subquery</strong>类似，只不过访问子查询中的表时使用的是普通的索引。</p>
<h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>全表扫描方式。</p>
<h3 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h3><p>全文检索时会使用该方式。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-07-10T03:46:01.000Z"><a href="/2019/07/10/Http协议下载非ASCII文件名文件/">2019-07-10</a></time>
      
      
  
    <h1 class="title"><a href="/2019/07/10/Http协议下载非ASCII文件名文件/">Http协议下载非ASCII文件名文件</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://blog.robotshell.org/2012/deal-with-http-header-encoding-for-file-download/" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>在使用自建的OSS时，发现使用Safari下载中文名文件，文件名是乱码，如果在响应头中将文件名使用UTF-8进行URLEncode，又会直接拿到编码过后的文件名。研究之后发现其实还是HTTP的曲折发展史造成的问题。</p>
<h3 id="RFC-5987"><a href="#RFC-5987" class="headerlink" title="RFC 5987"></a>RFC 5987</h3><ul>
<li>RFC 2068</li>
<li>RFC 2616</li>
<li>RFC 5987</li>
</ul>
<p>HTTP 1.1协议历经三代发展，从最初的不支持非ASCII文件名到支持UTF-8，中间阶段不同的UA使用了不同的方式对非ASCII文件名进行了支持。最终由RFC 5987结束了这种混乱的局面。<br>最佳的解决方案如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//filename需要使用RFC 3986标准声明的“百分号URL编码”</span><br><span class="line">Content-Disposition: attachment;filename=&quot;%e2%82%ac%20rates.txt&quot;; filename*=utf-8&apos;&apos;%e2%82%ac%20rates.txt</span><br></pre></td></tr></table></figure>

<p>这种方式既兼容使用旧标准(RFC 2616)的IE，同时也兼容使用新标准(RFC 5987)的UA，完美的解决了多语言的问题（唯一的小瑕疵是需要有一个ASCII编码的后缀）。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-07-06T16:17:02.000Z"><a href="/2019/07/07/谈谈resole-conf/">2019-07-07</a></time>
      
      
  
    <h1 class="title"><a href="/2019/07/07/谈谈resole-conf/">谈谈resolve.conf</a></h1>
  

    </header>
    <div class="entry">
      
        <p>&emsp;<strong>/etc/resolve.conf</strong>文件大家应该很熟悉了，最近被同事问到修改该文件后后总是自动还原的问题，在这里做一个简单的记录。</p>
<h3 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h3><table>
<thead>
<tr>
<th>系统类型</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu Server</td>
<td>18.04</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;nameserver 114.114.114.114&apos; &gt; /etc/resolve.conf</span><br><span class="line">cat /etc/resolve.conf</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure>

<p>一段时间后…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolve.conf</span><br><span class="line"># Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)</span><br><span class="line">#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN</span><br><span class="line"># 127.0.0.53 is the systemd-resolved stub resolver.</span><br><span class="line"># run &quot;systemd-resolve --status&quot; to see details about the actual nameservers.</span><br><span class="line"></span><br><span class="line">nameserver 127.0.0.53</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>通过查看还原后的文件内容，发现两个关键信息</p>
<ul>
<li>systemd-resolve –status</li>
<li>nameserver 127.0.0.53</li>
</ul>
<p>这说明系统将DNS解析服务由systemd的resolve服务托管，resolve.conf文件也由该服务维护。如果想使用自定义DNS服务器，很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop systemd-resolve</span><br><span class="line">systemctl disable systemd-resolve</span><br><span class="line">echo &apos;nameserver 114.114.114.114&apos; &gt; /etc/resolve.conf</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>看文档，看提示信息。一切皆有迹可循。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-07-06T13:51:09.000Z"><a href="/2019/07/06/Spring中被代理对象内部调用/">2019-07-06</a></time>
      
      
  
    <h1 class="title"><a href="/2019/07/06/Spring中被代理对象内部调用/">Spring中被代理对象内部调用</a></h1>
  

    </header>
    <div class="entry">
      
        <p>&emsp;众所周知，Spring AOP是基于动态代理实现的，最近被同事问到在被代理对象中直接进行内部调用，拦截器或切面不生效的问题，在这里做一个简单的记录。<br></p>
<h3 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h3><p>Spring版本：5.1.6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Impl&#123;</span><br><span class="line"></span><br><span class="line">    public void a()&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void b()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;如上所示，在Impl类外部调用a方法时，针对b方法的拦截器或切面并不能生效。原因是这种情形下，this代表被代理对象，调用并没有通过代理对象执行。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>确保使用CGLIB并将代理对象暴露给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取代理对象，强制转型为被代理对象（这里牵扯到CGlLIB的特点，代理对象其实是被代理对象的子类实例）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//继续使用上面的例子</span><br><span class="line">public void a()&#123;</span><br><span class="line">    ((Impl)AopContext.currentProxy()).b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-21T06:38:40.000Z"><a href="/2019/04/21/JVM堆内存详解/">2019-04-21</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/21/JVM堆内存详解/">JVM堆内存详解</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://blog.51cto.com/lizhenliang/2164876?wx=" target="_blank" rel="noopener">From 51CTO</a><br></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>JAVA堆内存管理是影响性能主要因素之一。<br>堆内存溢出是JAVA项目非常常见的故障，在解决该问题之前，必须先了解下JAVA堆内存是怎么工作的，如图：<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/jvm_heap_detail/java_heap_structure.png" alt="image"></p>
<ol>
<li>JVM内存划分为堆内存和非堆内存，堆内存分为年轻代（Young Generation）、老年代（Old Generation），非堆内存就一个永久代（Permanent Generation）。</li>
<li>年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。</li>
<li>堆内存用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收。</li>
<li>非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。</li>
</ol>
<p>在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。<br>元空间有注意有两个参数：</p>
<ul>
<li>MetaspaceSize ：初始化元空间大小，控制发生GC阈值</li>
<li>MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</li>
</ul>
<h3 id="为什么移除永久代？"><a href="#为什么移除永久代？" class="headerlink" title="为什么移除永久代？"></a>为什么移除永久代？</h3><p>移除永久代原因：为融合HotSpot JVM与JRockit VM（新JVM技术）而做出的改变，因为JRockit没有永久代。<br>有了元空间就不再会出现永久代OOM问题了！</p>
<h3 id="分代概念"><a href="#分代概念" class="headerlink" title="分代概念"></a>分代概念</h3><p>新生成的对象首先放到年轻代Eden区，当Eden空间满了，触发Minor GC，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。<br>老年代存储长期存活的对象，占满时会触发Major GC=Full GC，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时。</p>
<ul>
<li>Minor GC ： 清理年轻代 </li>
<li>Major GC ： 清理老年代</li>
<li>Full GC ： 清理整个堆空间，包括年轻代和永久代<br>所有GC都会停止应用所有线程。</li>
</ul>
<h3 id="为什么分代？"><a href="#为什么分代？" class="headerlink" title="为什么分代？"></a>为什么分代？</h3><p>将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及GC频率。针对分类进行不同的垃圾回收算法，对算法扬长避短。</p>
<h3 id="为什么survivor分为两块相等大小的幸存空间？"><a href="#为什么survivor分为两块相等大小的幸存空间？" class="headerlink" title="为什么survivor分为两块相等大小的幸存空间？"></a>为什么survivor分为两块相等大小的幸存空间？</h3><p>主要为了解决碎片化。如果内存碎片化严重，也就是两个对象占用不连续的内存，已有的连续内存不够新对象存放，就会触发GC。</p>
<h3 id="JVM堆内存常用参数"><a href="#JVM堆内存常用参数" class="headerlink" title="JVM堆内存常用参数"></a>JVM堆内存常用参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>堆内存初始大小，单位m、g</td>
</tr>
<tr>
<td>-Xmx（MaxHeapSize）</td>
<td>堆内存最大允许大小，一般不要大于物理内存的80%</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>非堆内存最大允许大小</td>
</tr>
<tr>
<td>-XX:NewSize（-Xns）</td>
<td>年轻代内存初始大小</td>
</tr>
<tr>
<td>-XX:MaxNewSize（-Xmn）</td>
<td>年轻代内存最大允许大小，也可以缩写</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td>
</tr>
<tr>
<td>-Xss</td>
<td>堆栈内存大小</td>
</tr>
</tbody></table>
<h3 id="垃圾回收算法（GC，Garbage-Collection）"><a href="#垃圾回收算法（GC，Garbage-Collection）" class="headerlink" title="垃圾回收算法（GC，Garbage Collection）"></a>垃圾回收算法（GC，Garbage Collection）</h3><p>红色是标记的非活动对象，绿色是活动对象。</p>
<ul>
<li><p>标记-清除（Mark-Sweep）<br>GC分为两个阶段，标记和清除。首先标记所有可回收的对象，在标记完成后统一回收所有被标记的对象。同时会产生不连续的内存碎片。碎片过多会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存，而不得已再次触发GC。<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/jvm_heap_detail/mark-sweep.png" alt="image"></p>
</li>
<li><p>复制（Copy）<br>将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/jvm_heap_detail/copy.png" alt="image"></p>
</li>
<li><p>标记-整理（Mark-Compact）<br>也分为两个阶段，首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。<br>一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。<br><img src="https://raw.githubusercontent.com/captainjack0x7C8/image/master/jvm_heap_detail/mark-compact.png" alt="image"></p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></li>
<li><p>串行收集器（Serial）</p>
</li>
</ul>
<p>比较老的收集器，单线程。收集时，必须暂停应用的工作线程，直到收集结束。</p>
<ul>
<li>并行收集器（Parallel）</li>
</ul>
<p>多条垃圾收集线程并行工作，在多核CPU下效率更高，应用线程仍然处于等待状态。</p>
<ul>
<li>CMS收集器（Concurrent Mark Sweep）<br>CMS收集器是缩短暂停应用时间为目标而设计的，是基于标记-清除算法实现，整个过程分为4个步骤，包括：<ul>
<li>初始标记（Initial Mark） </li>
<li>并发标记（Concurrent Mark）</li>
<li>重新标记（Remark）</li>
<li>并发清除（Concurrent Sweep）</li>
</ul>
</li>
</ul>
<p>其中，初始标记、重新标记这两个步骤仍然需要暂停应用线程。初始标记只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段是标记可回收对象，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，这个阶段暂停时间比初始标记阶段稍长一点，但远比并发标记时间段。<br>由于整个过程中消耗最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，CMS收集器内存回收与用户一起并发执行的，大大减少了暂停时间。</p>
<ul>
<li>G1收集器（Garbage First）<br>G1收集器将堆内存划分多个大小相等的独立区域（Region），并且能预测暂停时间，能预测原因它能避免对整个堆进行全区收集。G1跟踪各个Region里的垃圾堆积价值大小（所获得空间大小以及回收所需时间），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，从而保证了再有限时间内获得更高的收集效率。G1收集器工作工程分为4个步骤，包括：<ul>
<li>初始标记（Initial Mark）</li>
<li>并发标记（Concurrent Mark）</li>
<li>最终标记（Final Mark）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
</li>
</ul>
<p>初始标记与CMS一样，标记一下GC Roots能直接关联到的对象。并发标记从GC Root开始标记存活对象，这个阶段耗时比较长，但也可以与应用线程并发执行。而最终标记也是为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录。最后在筛选回收阶段对各个Region回收价值和成本进行排序，根据用户所期望的GC暂停时间来执行回收。</p>
<h3 id="垃圾收集器参数"><a href="#垃圾收集器参数" class="headerlink" title="垃圾收集器参数"></a>垃圾收集器参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseSerialGC</td>
<td>串行收集器</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>并行收集器</td>
</tr>
<tr>
<td>-XX:+UseParallelGCThreads=8</td>
<td>并行收集器线程数，同时有多少个线程进行垃圾回收，一般与CPU数量相等</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>指定老年代为并行收集</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>CMS收集器（并发收集器）</td>
</tr>
<tr>
<td>-XX:+UseCMSCompactAtFullCollection</td>
<td>开启内存空间压缩和整理，防止过多内存碎片</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompaction=0</td>
<td>表示多少次Full GC后开始压缩和整理，0表示每次Full GC后立即执行压缩和整理</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction=80%</td>
<td>表示老年代内存空间使用80%时开始执行CMS收集，防止过多的Full GC</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1收集器</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=0</td>
<td>在年轻代经过几次GC后还存活，就进入老年代，0表示直接进入老年代</td>
</tr>
</tbody></table>
<h3 id="为什么会堆内存溢出？"><a href="#为什么会堆内存溢出？" class="headerlink" title="为什么会堆内存溢出？"></a>为什么会堆内存溢出？</h3><p>在年轻代中经过GC后还存活的对象会被复制到老年代中。当老年代空间不足时，JVM会对老年代进行完全的垃圾回收（Full GC）。如果GC后，还是无法存放从Survivor区复制过来的对象，就会出现OOM（Out of Memory）。</p>
<h5 id="OOM（Out-of-Memory）异常常见有以下几个原因："><a href="#OOM（Out-of-Memory）异常常见有以下几个原因：" class="headerlink" title="OOM（Out of Memory）异常常见有以下几个原因："></a>OOM（Out of Memory）异常常见有以下几个原因：</h5><ol>
<li>老年代内存不足：java.lang.OutOfMemoryError:Javaheapspace</li>
<li>永久代内存不足：java.lang.OutOfMemoryError:PermGenspace</li>
<li>代码bug，占用内存无法及时回收。</li>
</ol>
<p>OOM在这几个内存区都有可能出现，实际遇到OOM时，能根据异常信息定位到哪个区的内存溢出。<br>可以通过添加个参数-XX:+HeapDumpOnOutMemoryError，让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。</p>
<p>熟悉了JAVA内存管理机制及配置参数，下面是对JAVA应用启动选项调优配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot;-server -Xms512m -Xmx2g -XX:+UseG1GC -XX:SurvivorRatio=6 -XX:MaxGCPauseMillis=400 -XX:G1ReservePercent=15 -XX:ParallelGCThreads=4 -XX:</span><br><span class="line">ConcGCThreads=1 -XX:InitiatingHeapOccupancyPercent=40 -XX:+PrintGCDetails  -XX:+PrintGCTimeStamps -Xloggc:/var/log/gc.log&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置堆内存最小和最大值，最大值参考历史利用率设置</li>
<li>设置GC垃圾收集器为G1</li>
<li>启用GC日志，方便后期分析</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>选择高效的GC算法，可有效减少停止应用线程时间。</li>
<li>频繁Full GC会增加暂停时间和CPU使用率，可以加大老年代空间大小降低Full GC，但会增加回收时间，根据业务适当取舍。</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-20T02:02:04.000Z"><a href="/2019/04/20/浅谈ClassLoader双亲委派/">2019-04-20</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/20/浅谈ClassLoader双亲委派/">浅谈ClassLoader双亲委托</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>双亲委拖：当类加载器A被请求加载某个类B,则A并不会直接去加载B,而是把这个请求委派给父类加载器C,每一层的类加载器都是如此,因此所有的类加载请求都会委派到顶端的启动类加载器;只有当父类加载器在其搜索范围内不能找到所需的类后,把结果反馈给子类加载器,子类加载器才会尝试去直接加载。</p>
<p>JDK中类加载器分类如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BootStrap ClassLoader</td>
<td>cpp实现，负责加载JAVA_HOME/lib下的类</td>
</tr>
<tr>
<td>Extension ClassLoader</td>
<td>java实现，负责加载JAVA_HOME/lib/ext下的类</td>
</tr>
<tr>
<td>Application ClassLoader</td>
<td>java实现，负责加载程序入口目录下的类</td>
</tr>
<tr>
<td>User ClassLoader</td>
<td>用户自定义</td>
</tr>
</tbody></table>
<p>双亲委拖正是基于以上类加载器的设定，明确了类加载的分工和过程，确保类加载器只加载负责范围内的类，从而不会造成混乱。</p>
<blockquote>
<p>对于任意类，都由加载它的类加载器和类本身确定其在JVM中的唯一性。如果同一个类被不同的类加载器加载为不同的实例，则有可能会出现异常（例如行为异常，无法强制转型）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  The</span><br><span class="line"> * default implementation of this method searches for classes in the</span><br><span class="line"> * following order:</span><br><span class="line"> *</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> *</span><br><span class="line"> *   &lt;li&gt;&lt;p&gt; Invoke &#123;@link #findLoadedClass(String)&#125; to check if the class</span><br><span class="line"> *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method</span><br><span class="line"> *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class</span><br><span class="line"> *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;@link #findClass(String)&#125; method to find the</span><br><span class="line"> *   class.  &lt;/p&gt;&lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If the class was found using the above steps, and the</span><br><span class="line"> * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the &#123;@link</span><br><span class="line"> * #resolveClass(Class)&#125; method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override &#123;@link</span><br><span class="line"> * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span><br><span class="line"> * &#123;@link #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;&#125; method</span><br><span class="line"> * during the entire class loading process.</span><br><span class="line"> *</span><br><span class="line"> * @param  name</span><br><span class="line"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span><br><span class="line"> *</span><br><span class="line"> * @param  resolve</span><br><span class="line"> *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class</span><br><span class="line"> *</span><br><span class="line"> * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span><br><span class="line"> *</span><br><span class="line"> * @throws  ClassNotFoundException</span><br><span class="line"> *          If the class could not be found</span><br><span class="line"> */</span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.</span><br><span class="line"> * This method should be overridden by class loader implementations that</span><br><span class="line"> * follow the delegation model for loading classes, and will be invoked by</span><br><span class="line"> * the &#123;@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method after checking the</span><br><span class="line"> * parent class loader for the requested class.  The default implementation</span><br><span class="line"> * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @param  name</span><br><span class="line"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span><br><span class="line"> *</span><br><span class="line"> * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span><br><span class="line"> *</span><br><span class="line"> * @throws  ClassNotFoundException</span><br><span class="line"> *          If the class could not be found</span><br><span class="line"> *</span><br><span class="line"> * @since  1.2</span><br><span class="line"> */</span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-01T02:15:40.000Z"><a href="/2019/03/01/Feign的继承支持/">2019-03-01</a></time>
      
      
  
    <h1 class="title"><a href="/2019/03/01/Feign的继承支持/">Feign的继承支持</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html#spring-cloud-feign-inheritance" target="_blank" rel="noopener">译自Spring Cloud Document</a></p>
<h2 id="7-7-Feign的继承支持"><a href="#7-7-Feign的继承支持" class="headerlink" title="7.7 Feign的继承支持"></a>7.7 Feign的继承支持</h2><p>Feign通过单继承接口支持模板apis。这样可以把常用操作通过接口进行分组。</p>
<h6 id="UserService-java"><a href="#UserService-java" class="headerlink" title="UserService.java."></a>UserService.java.</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(method = RequestMethod.GET, value =&quot;/users/&#123;id&#125;&quot;)</span><br><span class="line">    User getUser(@PathVariable(&quot;id&quot;) long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="UserResource-java"><a href="#UserResource-java" class="headerlink" title="UserResource.java."></a>UserResource.java.</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserResource implements UserService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="UserClient-java"><a href="#UserClient-java" class="headerlink" title="UserClient.java."></a>UserClient.java.</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package project.user;</span><br><span class="line"></span><br><span class="line">@FeignClient(&quot;users&quot;)</span><br><span class="line">public interface UserClient extends UserService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常不建议在服务器和客户端之间共享接口（Java Interface）。这是一种紧耦合，而且这样也无法使用Spring MVC（方法中的参数映射不会被继承）。</p>
</blockquote>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:captainjack0x7c8.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/AOP/">AOP</a><small>1</small></li>
  
    <li><a href="/tags/Feign/">Feign</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>1</small></li>
  
    <li><a href="/tags/JDK/">JDK</a><small>4</small></li>
  
    <li><a href="/tags/JVM/">JVM</a><small>1</small></li>
  
    <li><a href="/tags/MySQL/">MySQL</a><small>1</small></li>
  
    <li><a href="/tags/RFC/">RFC</a><small>1</small></li>
  
    <li><a href="/tags/Spring-Cloud/">Spring Cloud</a><small>1</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>1</small></li>
  
    <li><a href="/tags/算法/">算法</a><small>2</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 captainjack0x7c8
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
